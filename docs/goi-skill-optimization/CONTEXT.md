# GOI Skill 优化 - 背景与现状

> 参考 Claude Code 的 Skill 机制，优化 GOI 提示词架构，提升执行效率和可扩展性

## 1. 问题背景

### 1.1 当前痛点

**性能问题：执行慢**

用户反馈 GOI 执行任务时响应缓慢，主要原因：

1. **提示词过长**：`planPrompt.ts` 约 500 行，包含 17 种资源类型的完整定义
2. **Token 开销大**：每次 LLM 调用约 4000+ tokens
3. **多次 LLM 调用**：规划 1 次 + 每步验证 1 次，3 步任务 = 4 次调用
4. **步骤间延迟**：`stepDelay: 500ms` 累积

**扩展性问题：越加越慢**

| 现状 | 风险 |
|------|------|
| 17 种资源类型 | 提示词已经很长 |
| 新增资源类型 | 提示词更长，token 成本上升 |
| 更多页面交互 | 更多边界情况，LLM 容易出错 |

### 1.2 根本原因

当前采用**单一大提示词**架构：

```
用户: "创建一个提示词"
    ↓
加载完整 planPrompt（所有 17 种资源类型定义）
    ↓
LLM 处理大量无关信息（数据集、任务、监控等）
    ↓
输出结果（可能因信息过载而出错）
```

**问题本质**：无论用户请求什么，都加载全部知识，违背了"按需加载"原则。

## 2. 现有提示词分析

### 2.1 提示词清单

| 文件 | 用途 | 行数 | 问题 |
|------|------|------|------|
| `planPrompt.ts` | 计划生成 | ~500 | 包含所有资源类型，过于臃肿 |
| `verifyPrompt.ts` | 结果验证 | ~320 | 大部分场景可用规则替代 |
| `parser.ts` | 意图解析 | ~200+ | 规则 + LLM 混合，相对合理 |

### 2.2 planPrompt.ts 内容分析

```
planPrompt.ts 结构：
├── 系统角色定义（~50 行）
├── GOI 三原语说明（~100 行）
│   ├── Access 操作
│   ├── State 操作
│   └── Observation 操作
├── 资源类型表（~50 行，17 种类型）
├── 变量引用语法（~50 行）
├── 资源名称引用语法（~30 行）
├── 操作示例（~150 行）
│   ├── State 创建示例
│   ├── Observation 查询示例
│   └── 完整场景示例
├── 不支持的任务类型（~30 行）
└── 输出格式说明（~40 行）
```

**核心问题**：不管用户请求什么，LLM 都要阅读完整 500 行提示词。

### 2.3 LLM 调用流程

```
用户命令
    ↓
[LLM 调用 1] 规划 - planPrompt（~4000 tokens）
    ↓
步骤 1 执行
    ↓
[LLM 调用 2] 验证 - verifyPrompt（~2000 tokens）
    ↓
步骤 2 执行
    ↓
[LLM 调用 3] 验证
    ↓
...
```

一个 3 步骤任务 = **4 次 LLM 调用**，约 **10000+ tokens**。

## 3. 优化方向：Skill 机制

### 3.1 Claude Code Skill 机制

Claude Code 的 Skill 是一种**按需加载的模块化知识**：

- **模型自主发现**：根据用户输入自动匹配相关 Skill
- **语义激活**：通过 description 字段实现触发
- **知识补充**：只加载 Claude 不知道的项目特定信息

**核心设计原则**：

1. 保持简洁 - 只添加模型不知道的知识
2. 按需加载 - 根据任务类型动态组合
3. 渐进式披露 - 主文档精简，详情放子文件

### 3.2 应用到 GOI

**优化后的流程**：

```
用户: "创建一个提示词"
    ↓
意图识别 → 检测到 "提示词" 关键词
    ↓
加载 core-skill（GOI 核心语法）+ prompt-skill（提示词操作）
    ↓
LLM 处理精简信息（~100 行 vs ~500 行）
    ↓
输出结果（更准确、更快）
```

### 3.3 预期收益

| 指标 | 当前 | 优化后 | 提升 |
|------|------|--------|------|
| 提示词长度 | ~500 行 | ~100 行 | **80%** |
| Token 数 | ~4000 | ~800 | **80%** |
| 响应时间 | 慢 | 快 2-3x | **显著** |
| 出错率 | 高 | 低 | **降低** |
| 扩展成本 | 每加一个类型都变慢 | 独立 Skill，互不影响 | **解耦** |

## 4. 相关文件

### 4.1 现有代码位置

```
apps/web/src/lib/goi/
├── prompts/
│   ├── planPrompt.ts      # 计划生成提示词（待拆分）
│   ├── verifyPrompt.ts    # 验证提示词（待优化）
│   └── index.ts
├── intent/
│   └── parser.ts          # 意图解析器（需扩展）
├── agent/
│   ├── agentLoop.ts       # Agent 主循环
│   ├── planner.ts         # 计划器
│   └── verifier.ts        # 验证器
└── executor/
    ├── accessHandler.ts   # Access 操作处理
    ├── stateHandler.ts    # State 操作处理
    └── observationHandler.ts  # Observation 操作处理
```

### 4.2 参考文档

- [Claude Code Skill 机制研究](#) - 本次优化的参考来源
- [GOI Intelligence Roadmap](../goi-intelligence-roadmap.md) - GOI 智能等级路线图
- [GOI Best Practices](../goi-best-practices.md) - GOI 开发最佳实践
- [GOI 论文 2510.04607v1.pdf](../2510.04607v1.pdf) - 原始 GOI 设计论文

## 5. 约束条件

### 5.1 兼容性要求

- 保持现有 GOI 三原语语法不变
- 保持现有 API 接口不变
- 保持 TODO List 数据结构不变

### 5.2 渐进式实施

- 先实现 Skill 加载机制
- 逐步拆分资源类型 Skill
- 保留回退到完整提示词的能力
- 通过 A/B 测试验证效果

## 6. 成功标准

| 标准 | 指标 |
|------|------|
| 性能提升 | 平均响应时间减少 50%+ |
| Token 节省 | 单次调用 token 减少 60%+ |
| 准确率保持 | 任务成功率不低于当前水平 |
| 可扩展性 | 新增资源类型不增加基础提示词长度 |
